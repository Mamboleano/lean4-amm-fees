{"name":"Init.Grind.Util","instances":[],"imports":["Init.Core"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L74-L78","name":"Lean.Grind.offsetUnexpander","line":74,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.offsetUnexpander","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.offsetUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">offsetUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L68-L72","name":"Lean.Grind.eqMatchUnexpander","line":68,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.eqMatchUnexpander","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.eqMatchUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">eqMatchUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L62-L66","name":"Lean.Grind.matchCondUnexpander","line":62,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.matchCondUnexpander","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.matchCondUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">matchCondUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L56-L60","name":"Lean.Grind.nestedProofUnexpander","line":56,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProofUnexpander","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProofUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProofUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L53-L54","name":"Lean.Grind.nestedProof_congr","line":53,"kind":"theorem","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProof_congr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProof_congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProof_congr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hp</span> : <span class=\"fn\">p</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hq</span> : <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\">⋯</span> <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L47-L51","name":"Lean.Grind.PreMatchCond","line":47,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.PreMatchCond","doc":"Similar to `MatchCond`, but not reducible. We use it to ensure `simp`\nwill not eliminate it. After we apply `simp`, we replace it with `MatchCond`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.PreMatchCond\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">PreMatchCond</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L39-L45","name":"Lean.Grind.MatchCond","line":39,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.MatchCond","doc":"Gadget for annotating conditions of `match` equational lemmas.\nWe use this annotation for two different reasons:\n- We don't want to normalize them.\n- We have a propagator for them.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.MatchCond\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MatchCond</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L32-L37","name":"Lean.Grind.EqMatch","line":32,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.EqMatch","doc":"Gadget for annotating the equalities in `match`-equations conclusions.\n`_origin` is the term used to instantiate the `match`-equation using E-matching.\nWhen `EqMatch a b origin` is `True`, we mark `origin` as a resolved case-split.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.EqMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EqMatch</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">_origin</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L29-L30","name":"Lean.Grind.eqBwdPattern","line":29,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.eqBwdPattern","doc":"Gadget for representing `a = b` in patterns for backward propagation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.eqBwdPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">eqBwdPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L26-L27","name":"Lean.Grind.offset","line":26,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.offset","doc":"Gadget for representing offsets `t+k` in patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.offset\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">offset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L14-L24","name":"Lean.Grind.simpMatchDiscrsOnly","line":14,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.simpMatchDiscrsOnly","doc":"Gadget for marking `match`-expressions that should not be reduced by the `grind` simplifier, but the discriminants should be normalized.\nWe use it when adding instances of `match`-equations to prevent them from being simplified to true.\n\nRemark: it must not be marked as `[reducible]`. Otherwise, `simp` will reduce\n```\nsimpMatchDiscrsOnly (match 0 with | 0 => true | _ => false) = true\n```\nusing `eq_self`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.simpMatchDiscrsOnly\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">simpMatchDiscrsOnly</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/11ccbced796476be020459a83c599b301a765d3e/src/Init/Grind/Util.lean#L11-L12","name":"Lean.Grind.nestedProof","line":11,"kind":"def","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProof","doc":"A helper gadget for annotating nested proofs in goals. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProof\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">h</span> : <span class=\"fn\">p</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>"}]}